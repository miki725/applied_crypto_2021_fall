#! /usr/bin/env bash

set -e -u -o pipefail

# If the solution includes setup.sh, run that first. If the solution needs any
# extra dependencies, this is where the `apt-get install` commands should go.
# Ignore the exit status.
if [[ -e /autograder/submission/setup.sh ]] ; then
    echo "Running setup.sh..."
    bash -x /autograder/submission/setup.sh || true
fi

# Execute the solution using the grading input. run_solution.py suppresses the
# solution's exit status, so an early exit here will only happen if no solution
# is found.
echo "Running solution..."
if python3 /autograder/run_solution.py \
    /autograder/submission \
    < /autograder/grading_input.json \
    > /tmp/solution_stdout \
    2> /tmp/solution_stderr
then
    solution_found=1
else
    solution_found=0
fi

solution_outputs="$(
    echo "stdout:"
    cat /tmp/solution_stdout
    echo
    echo "stderr:"
    cat /tmp/solution_stderr
)"
echo "$solution_outputs"

if [[ "$solution_found" = 0 ]] ; then
    # run_solution.py only fails when the solution is not found or fails to
    # execute. In that case, reveal its output through Gradescope. (Normally we
    # don't want to reveal output, because the correct answers are supposed to
    # remain secret.)
    echo "$solution_outputs" | python3 -c \
        'import sys; import json; json.dump({"score":0,"output":sys.stdin.read()}, sys.stdout)' \
        > /autograder/results/results.json
else
    # Grade the output.
    echo "Grading..."
    mkdir -p /autograder/results
    python3 /autograder/grade.py \
        /autograder/grading_input.json \
        /autograder/grading_output.json \
        /tmp/solution_stdout \
        > /autograder/results/results.json
fi

# Cat the results so that we can see them if we're grading manually.
cat /autograder/results/results.json
echo
